# -*- coding: utf-8 -*-
"""galaxia_visão_computacional.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KJAIvITHN8PCPdfMv_pj7lWeR-inrLn4

# *0 Importando as bibliotecas necessárias*
"""

import cv2
#from cv2 import cvtColor
#from google.colab.patches import cv2_imshow
from matplotlib import pyplot as plt
import numpy as np

"""# *1 Mostrar propriedades de uma imagem: largura, altura e quantidade de canais em pixels*"""

#função usada para abrir a imagem através de cv2. imread() que leva como argumento o nome do arquivo em disco
imagem = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
imagem = cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB)

# Mostrar a imagem com a função plt.imshow da matplotlib
plt.imshow(imagem)
plt.title("Galáxia Original") #colocar título na imagem
plt.show()

# Salvar a imagem no disco com função imwrite()
imagem = cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB) #trocar a cor BGR para RGB
cv2.imwrite("galaxia_original.jpg", imagem)

cv2.waitKey(0) #mostrar a imagem em uma janela, espera pressionar qualquer tecla
               #para fechar

#Para saber largura, altura e quantidade da imagem
print('Largura em pixels: ', end='')
print(imagem.shape[1]) #largura da imagem
print('Altura em pixels: ', end='')
print(imagem.shape[0]) #altura da imagem
print('Qtde de canais: ', end='')
print(imagem.shape[2]) #qtde de canais da imagem

"""# *2 Sistema de coordenadas e manipulação de pixels*

"""

(b, g, r) = imagem[0, 0] #veja que a ordem BGR e não RGB
print('O pixel (0, 0) tem as seguintes cores:')
print('Vermelho:', r,'-', 'Verde:', g,'-', 'Azul:', b)

(b, g, r) = imagem[50, 50] #veja que a ordem BGR e não RGB
print('O pixel (167, 298) tem as seguintes cores:')
print('Vermelho:', r,'-', 'Verde:', g,'-', 'Azul:', b)

"""## *Outra possibilidade é utilizar dois laços de repetição para “varrer” todos os pixels da imagem. Lembrando que o custo do algoritmo é alto, pois precisa "varrer" toda imagem.* 
   Cores mais comuns em RGB
1.   Branco - RGB (255,255,255)
2.   Azul - RGB (0,0,255)
3.   Vermelho - RGB (255,0,0)
4.   Verde - RGB (0,255,0)
5.   Amarelo - RGB (255,255,0)
6.   Magenta - RGB (255,0,255)
7.   Ciano - RGB (0,255,255)
8.   Preto - RGB (0,0,0)
"""

#utilizando sistema de 'varrer'todos os pixels da imagem
#O resultado é uma imagem com todos os pixels substituídos pela cor azul RGB(0,0,255)

img_percorrer = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
img_percorrer = cv2.cvtColor(img_percorrer, cv2.COLOR_BGR2RGB)

for y in range(0, img_percorrer.shape[0]):
 for x in range(0, img_percorrer.shape[1]):
   img_percorrer[y, x] = (0,0,255) #em alguns casos, veja que a ordem BGR e não RGB

plt.imshow(img_percorrer)
plt.title("Imagem modificada, todos pixels azul")
plt.show()
cv2.waitKey(0)

#incluíndo as variáveis de linha e coluna para serem componentes de cor
img_var_cor = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')

for y in range(0, img_var_cor.shape[0]): #percorre linhas
 for x in range(0, img_var_cor.shape[1]): #percorre colunas
  img_var_cor[y, x] = (x%256,y%256,x%256) #lembrando que as variáveis componentes da cor devem assumir 
                                          #o valor entre 0 e 255, então utilizamos a operação 
                                          #“resto da divisão por 256” para manter o resultado entre 0 e 255.
plt.imshow(img_var_cor)
plt.title("Imagem modificada com variáveis como componente de cor")
plt.show()
cv2.waitKey(0)

"""Veja que utilizamos os valores de linha multiplicado pela coluna (x*y) no componente “R”, 
(lembrando que é BGR e não RGB), da tupla que forma a cor de cada pixel e deixamos o 
componente azul e verde zerados. 
A dinâmica da mudança de linhas e colunas gera esta imagem.
"""
#Verificar se está em RGB ou BGR
img_valor_X_linha = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')

for y in range(0, img_valor_X_linha.shape[0], 1): #percorre as linhas
 for x in range(0, img_valor_X_linha.shape[1], 1): #percorre as colunas
  img_valor_X_linha[y, x] = ((x*y)%256, 0, 0)

plt.imshow(img_valor_X_linha)
plt.title("Imagem com valores de linhas modificados")
plt.show()
cv2.waitKey(0)

"""saltar a cada 10 pixels ao percorrer as linhas e mais 10 pixels ao percorrer as colunas. 
A cada salto é criado um quadrado de 5x5 pixels
"""
image_quad = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
image_quad = cv2.cvtColor(image_quad, cv2.COLOR_BGR2RGB)

for y in range(0, image_quad.shape[0], 10): #percorre linhas
  for x in range(0, image_quad.shape[1], 10): #percorre colunas
    image_quad[y:y+5, x: x+5] = (0,0,0) #define a cor

plt.imshow(image_quad)
plt.title("Imagem modificada")
plt.show()
cv2.waitKey(0)

"""# *3 Fatiamento e desenho geométricos sobre a imagem*
## *Técnica de Slicing*
"""

#Para alterar vários pixeis da imagem de uma única vez
imagem_slicing = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#imagem_slicing = cv2.cvtColor(imagem_slicing, cv2.COLOR_BGR2RGB)

#Cria um retangulo azul por toda a largura da imagem
imagem_slicing[30:50, :] = (255, 0, 0)

#Cria um quadrado vermelho
imagem_slicing[100:150, 50:100] = (0, 0, 255)

#Cria um retangulo amarelo por toda a altura da imagem
imagem_slicing[:, 200:220] = (0, 255, 255)

#Cria um retangulo verde da linha 150 a 300 nas colunas 250 a 350
imagem_slicing[30:80, 250:270] = (0, 255, 0)

#Cria um quadrado ciano da linha 150 a 300 nas colunas 250 a 350
imagem_slicing[90:220, 150:180] = (255, 255, 0)

#Cria um quadrado branco
imagem_slicing[110:160, 230:260] = (255, 255, 255)

#Cria um quadrado preto
imagem_slicing[30:140, 50:70] = (0, 0, 0)

plt.imshow(imagem_slicing)
plt.title("Resultado de fatiamento de pixel da imagem")
plt.show()
cv2.waitKey(0)

#Varias figuras geométricas
img_geometricas = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
img_geometricas = cv2.cvtColor(img_geometricas, cv2.COLOR_BGR2RGB)

vermelho = (0, 0, 255)
verde = (0, 255, 0)
azul = (255, 0, 0)
magenta = (255, 0, 255)#RGB(255,0,255)
ciano = (255, 255, 0)#RGB(0,255,255)
amarelo = (0, 255, 255)#RGB(255,255,0)
branco = (255,255,255)
preto = (0,0,0)

cv2.line(img_geometricas, (0, 0), (100, 200), azul, 5)
cv2.line(img_geometricas, (300, 200), (100, 100), amarelo, 10)
cv2.rectangle(img_geometricas, (20, 20), (120, 120), vermelho, 5)
cv2.rectangle(img_geometricas, (200, 50), (225, 125), ciano, -1)

(X, Y) = (img_geometricas.shape[1] // 2, img_geometricas.shape[0] // 2)
for raio in range(0, 160, 15):
  cv2.circle(img_geometricas, (X, Y), raio, branco)

plt.imshow(img_geometricas)
plt.title("Varias Figuras Geométricas")
plt.show()

#Escrever na Imagem
img_escrita = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#img_escrita = cv2.cvtColor(img_escrita, cv2.COLOR_BGR2RGB)

fonte = cv2.FONT_HERSHEY_SIMPLEX
cv2.putText(img_escrita,'StarKiler',(20,140), fonte,2,(255, 255, 255),2,cv2.LINE_AA,)

plt.imshow(img_escrita)
plt.title("Imagem com escrita")
plt.show()

"""# *4 Transformações e máscaras*

## *4.1 Cortando uma imagem / Crop*
"""

#Recorte 
img_crop = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#img_crop = cv2.cvtColor(img_crop, cv2.COLOR_BGR2RGB)

recorte = img_crop[10:60, 100:160]
plt.imshow(recorte)
plt.title("Exibe recorte da imagem da linha 10 até a linha 60 e da coluna 101 até a coluna 160:")
plt.show()
cv2.waitKey(0)

"""## *4.2 Redimensionamento / Resize\*

plt.imshow(img_resize)
plt.show()
"""

"""
Importante: É preciso calcular a proporção da altura em relação a largura
da nova imagem, caso contrário ela poderá ficar distorcida.
"""
img_resize = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#img_resize = cv2.cvtColor(img_resize, cv2.COLOR_BGR2RGB)

largura = img_resize.shape[1]
altura = img_resize.shape[0]
proporcao = float(altura/largura)

largura_nova = 200 #em pixels
altura_nova = int(largura_nova*proporcao)
tamanho_novo = (largura_nova, altura_nova)

img_redimensionada = cv2.resize(img_resize,
tamanho_novo, interpolation = cv2.INTER_AREA) #A função ‘rezise’ utiliza uma propriedade definida como 
                                              #cv2.INTER_AREA que é uma especificação do cálculo matemático
                                              #para redimensionar a imagem.
plt.imshow(img_redimensionada)
plt.title("Imagem Redimensionada")
plt.show()

cv2.waitKey(0)

"""
Outra meneira de redimensionar imagem é utilizando a técnica de ‘slicing’.
#Neste caso, cortar pela metade o tamanho da imagem.
"""
img_resize_slicing = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
img_redimensionada_slicing = img_resize_slicing[::2,::2]
#img_redimensionada_slicing = cv2.cvtColor(img_redimensionada_slicing, cv2.COLOR_BGR2RGB)

plt.imshow(img_redimensionada_slicing)
plt.title("Técnica Slicing")
plt.show()
print("Largura:", img_redimensionada_slicing.shape[1], "pixels")
print("Altura: ", img_redimensionada_slicing.shape[0], "pixels")
cv2.waitKey(0)

"""## *4.3 Espelhando uma imagem / Flip*"""

#Espelhamento Horinzontal
flip_horizontal = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#flip_horizontal = cv2.cvtColor(flip_horizontal, cv2.COLOR_BGR2RGB)

#flip_horizontal = img_flip[::-1,:] #comando equivalente abaixo
flip_horizontal = cv2.flip(flip_horizontal, 1)

plt.imshow(flip_horizontal)
plt.title("Espelhamento Horinzontal")
plt.show()
cv2.waitKey(0)

flip_vertical = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#flip_vertical = cv2.cvtColor(flip_vertical, cv2.COLOR_BGR2RGB)

#flip_vertical = flip_vertical[:,::-1] #comando equivalente abaixo
flip_vertical = cv2.flip(flip_vertical, 0)

plt.imshow(flip_vertical)
plt.title("Espelhamento Vertical")
plt.show()
cv2.waitKey(0)

#h = horinzontal, v = vertical
flip_hv = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#flip_hv = cv2.cvtColor(flip_hv, cv2.COLOR_BGR2RGB)

flip_hv = flip_hv[::-1,::-1] #comando equivalente abaixo
#flip_hv = cv2.flip(img, -1)

plt.imshow(flip_hv)
plt.title("h = horinzontal, v = vertical")
plt.show()

cv2.waitKey(0)

"""## *4.4 Rotacionando uma imagem / Rotate*"""

img_rotate = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#img_rotate = cv2.cvtColor(img_rotate, cv2.COLOR_BGR2RGB) #transforamar BGR em RGB

(alt, lar) = img_rotate.shape[:2] #captura altura e largura
centro = (lar // 2, alt // 2) #acha o centro
M = cv2.getRotationMatrix2D(centro, 30, 1.0) #30 graus

img_rotacionada = cv2.warpAffine(img_rotate, M, (lar, alt))

plt.imshow(img_rotacionada)
plt.title("Imagem rotacionada em 30 graus")
plt.show()

cv2.waitKey(0)

"""## *4.5 Máscaras*"""

#uma máscara nada mais é que uma imagem onde cada pixel pode estar “ligado” ou “desligado”,
#ou seja, a máscara possui pixels pretos e brancos apenas.
img_mascara = cv2.imread('/home/claudio/Documentos/08_projects_github/python_opencv/src/imgs/galaxia_starwars.jpg')
#img_mascara = cv2.cvtColor(img_mascara, cv2.COLOR_BGR2RGB)

plt.imshow(img_mascara)
plt.title("Imagem Original")
plt.show()

mascara = np.zeros(img_mascara.shape[:2], dtype = "uint8")
(cX, cY) = (img_mascara.shape[1] // 2, img_mascara.shape[0] // 2)
cv2.circle(mascara, (cX, cY), 80, 255, -1)

img_com_mascara = cv2.bitwise_and(img_mascara, img_mascara, mask = mascara)


plt.imshow(img_com_mascara)
plt.title("Imagem com Aplicação da Mascára")
plt.show()

cv2.waitKey(0)